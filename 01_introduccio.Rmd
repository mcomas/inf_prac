---
title: "Pràctica 1. Introducció a R. Variables aleatòries."
output: html_document
---

* [El llenguatge R](#llenguatge_R)
* [Estructures de dades comuns](#estructures)
* [Les funcions](#funcions)
* [Variables aleatòries](#variables)
    * [Variable aleatòries discretes](#var_discretes)
    * [Variable aleatòries contínues](#var_continues)
* [Activitats](#activitats)


# El llenguatge R {#llenguatge_R}

R és un llenguatge de programació orientat principalment a l'anàlisi estadístic. La primera versió d'R va apareixer l'any 1992. R és un llenguatge funcional, aquest fet el fa semblant a altres llenguatges funcionals de programació com [Common Lisp](http://en.wikipedia.org/wiki/Common_Lisp) o [Haskell](http://en.wikipedia.org/wiki/Haskell_(programming_language)).

Alguns dels punts forts:

* És lliure, codi obert, i disponible per les principals plataformes. Si fas un anàlisi, 
  qualsevol persona el pot replicar.
  
* Té una immens conjunt de llibreries disponibles enfocades a diferents àrees d'anàlisi 
  de dades: models estadístics, machine learning, visualització, importació, manipulació 
  de dades. Qualsevol cosa que se t'acudeixi fer, el més probable és que ja existeixi 
  un paquet que faci el mateix o gairebé.

* Eines modernes. Els investigadors normalment publiquen els codis en R que han utilitzat 
  per a obtenir els seus resultats.
  
* Un llenguatge profundament establert per a l'anàlisi de dades. Capacitat de maneig 
  de valors perduts, data.frame, seleccions,...
  
* Comunitat activa. Trobaràs molt forums on podràs rebre ajuda per tot allò que vulguis 
  fer [R-help mailing list](https://stat.ethz.ch/mailman/listinfo/r-help), 
  [stackoverflow](http://stackoverflow.com/questions/tagged/r). També podeu connectar 
  amb altre gent que està aprenent R via [twitter](https://twitter.com/search?q=%23rstats), 
  [linkedin](http://www.linkedin.com/groups/R-Project-Statistical-Computing-77616).

* Eines per comunicar els teus resultats. Llibreries d'R permeten priduir resultats que són
  fàcils de compartir en html o pdf mitjançant [informes](http://yihui.name/knitr/), o per exemple crear
  [webs interactives](http://www.rstudio.com/shiny/).
  
* Disenyat per connectar-se amb facilitat amb altres llenguatges de programació com C, C++ i 
  Fortran.

Algunes de les principals mancances:

* La major part del codi R que trobareu per internet està escrit per resoldre un problema
  concret. Per tant, el codi pot no sé ni elegant, ni ràpid, ni fàcil d'entendre.

* Inconsistencia és un problema entre diferents llibreries, fins i tot dins de les llibreries
  base d'R. Pensa que quan aprenguis R estàs davant d'un llenguatge que ha evolucionat durant
  20 anys. Per tant, hi han moltes definicions historiques que poden confondre els fonaments 
  del llenguatge.
  
* R no és un llanguatge de programació especialment ràpid, i a més, un codi mal escrit pot ser
  encara més lent. R també tendeix a consumir molts recursos de memória. Tingueu-ho present a 
  l'hora d'escriure els vostres programes.
  

# Estructures de dades comuns {#estructures}

Aquesta secció resumeix les estructures de dades més comuns d'R. Si voleu aprofundir en alguna estructura concreta podeu accedir directament a la documentació d'R.

Les estructures de dades d'R es poden organitzar segons la seva dimensió (1d, 2d, or nd) i depènen 
de si són homogènies (tots els element de l'estructura són del mateix tipus) o heterogènies (els element de l'estructura poden diferir). Aquesta classificació dona lloc a les següents estructures de dades:


|    | Homogènies    | Heterogènies  |
|----|---------------|---------------|
| 1d | Atomic vector | List          |
| 2d | Matrix        | Data frame    |
| nd | Array         |               |

Gairebé tots els objectes d'R es construeixen a partir d'aquestes estructures bàsiques. Observeu que R no té estrutures 0 dimensionals, o sigui, escalars. Els números o cadenes de caràcters, que podríem pensar que ho són, són vectors de llargada 1.

Donat un objecte, la millor manera d'entedre quina és la seva estructura és a través de la comanda `str()` que és un diminutiu d'estrutura (structure). Aquesta comanda retorna un descripció general de l'estrucura de l'objecte.

## Vectors (1d) {#vectors}

L'estructura bàsica d'R és el vector. Els vectors poden ser de dos tipus: vectors atòmics (atomic vectors) i llistes (list). Tenen tres propietats en comú:

* Tipus, `typeof()`, què es?.
* Llargada, `length()`, quants elements conté?
* Atributs, `attributes()`, té altre informació associada?

Els dos objectes es diferencien per la tipologia dels seus element: tots els element d'un vector atómic han de ser del mateix tipus, mentres que els element d'una llista poden diferir.

Per veure si un objecte és un vector atómic utilitzarem la instrucció `is.atomic(x)`. Per veure si un objecte és una llista podem utilitzar la comanda `is.list(x)`. Si volem veure si un objecte és un vector atòmic o una llista podem utilitzar l'expressió `is.atomic(x) || is.list(x)`. Nota: existeix la comanda `is.vector(x)` la qual NO és equivalent a `is.atomic(x) || is.list(x)`, `is.vector` únicament `TRUE` si l'objecte no té atributs associats.

### Atomic vectors

En general, hi han quatre tipus de vectors atómics: logical, integer, numeric i character. De fet, hi han dos tipus més de dades que no entrarem a explicar: complex i raw.

Els vectors atómics normalment es creen a través de la funció `c()`, versió reduïda per combinar.

```{r}
num_var <- c(1, 2.5, 4.5)
# Utilitzant el sufix L, el valor es guarda com un enter enlloc d'un numeric
int_var <- c(1L, 6L, 10L)
# S'utilitza TRUE i FALSE (o T i F) per creat valors lògics
log_var <- c(TRUE, FALSE, T, F)
chr_var <- c("these are", "some strings")
```

El vectors atòmics són 1-dimensionals, encara que s'anidin comandes de `c()`:

```{r}
c(1, c(2, c(3, 4)))
# the same as
c(1, 2, 3, 4)
```

En R, un valor perdut s'especifica amb `NA`, que és un vector logic de llargada 1. `NA` es converteix sempre a la tipologia del vector on apareix. Tot i que en general no serà necessari, si es vol crear un `NA` d'un tipus específic, es pot utilitzar `NA_real_` (a double vector), `NA_integer_` and `NA_character_` enlloc de `NA`.

#### Tipus i tests de vectors

Donat un vector, pot deerminar el seu tipus amb `typeof()` o comprovar si el vector és d'un tipus específic amb la funció "is": `is.character()`, `is.double()`, `is.integer()`, `is.logical()`, o  de forma més general, `is.atomic()`.

```{r}
int_var <- c(1L, 6L, 10L)
typeof(int_var)
is.integer(int_var)
is.atomic(int_var)

dbl_var <- c(1, 2.5, 4.5)
typeof(dbl_var)
is.double(dbl_var)
is.atomic(dbl_var)
```

`is.numeric()` és un test general per decidir si un vector és numèric o no (integer o double).

```{r}
is.numeric(int_var)
is.numeric(dbl_var)
```

#### Conversió de tipus

Tots els elements d'un vector atómic han de ser del mateix tipus, així doncs, quan intentem combinar diferent tipus algun dels vector serà convertit al tipus més flexible. El tipus de menys a més flexibles són: logical, integer, double i character.

Per exemple, al combinar un caràcter i un enter dona lloc a un caràcter:

```{r}
str(c("a", 1))
```

Quan un vector logica és converteix a enter o doble, `TRUE` es converteix en 1 i `FALSE` en 0. Això és especialment útil juntament amb la funció `sum()` i `mean()`

```{r}
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)

# Nombre total TRUEs
sum(x)

# Proporció de TRUE
mean(x)
```

La conversió de tipus normalment succeeix de forma automàtica. La majoria de funcions matemàtiques (`+`, `log`, `abs`, etc.) convertiran a doble o enter, i la majoria d'operacions lógiques (`&`, `|`, `any`, etc) convertiran a logical. Normalment, quan això passi rebràs un missatge d'alerta si en el procés de conversió s'ha pogut perdre algun tipus d'informació. Per evitar confusions podem convertir manualment el tipus del nostre vector mitjançant les funcions `as.character()`, `as.double()`, `as.integer()` o `as.logical()`. 

### Les llistes (list)

Les llistes són diferents dels vectors atómics perquè els seus element poden ser de qualsevol tipus, fins i tot llistes. A diferència dels vectors atòmics que es construeixen amb la funció `c()`, pots construir llistes mitjançant la funció `list()`:

```{r}
x <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
str(x)
```

Com s'ha comentat, les llistes poden contenir altres llistes. Això les converteix en elements molt més versàtils que els vectors atòmics.

```{r}
x <- list(list(list(list())))
str(x)
```

La funció `c()` si s'aplica a una llista  o més, convertirà tots els elements en una sola llista. Compara el resultat de `list()` i `c()`:

```{r}
x <- list(list(1, 2), c(3, 4))
y <- c(list(1, 2), c(3, 4))
str(x)
str(y)
```

El tipus (`typeof()`) d'un llista és `list`. Pots testar si un objecte és una llista amb `is.list()` i convertir un objete a llista amb `as.list()`. Pots convertir una llista en un vector atómic mitjançant la comanda `unlist()`. Si els elements d'una llista són de diferent tipus, `unlist()` utilitzarà les mateixes regles que s'utilitzen amb `c()`, o sigui, es convertiran els elements al tipus més flexible.

Les estructures més avançades d'R es construeixen a partir de llistes. Per exemple, els data.frames (que en parlarem a continuació) i els model lineals (que veurem més endavant) són llistes:

```{r}
is.list(mtcars)

mod <- lm(mpg ~ wt, data = mtcars)
is.list(mod)
```

# Les funcions {#funcions}

Les funcions són la part més important del llenguatge R: per escriure codi eficient amb R és molt important entendre com funcionen les funcions. El més important és entendre que dins el llenguatge R
les funcions són objectes tal i com ho són els vectors que hem vist a l'apartat anterior.

Per definir una funció `f` s'utilitza la sintaxi següent:

```{r, eval = FALSE}
f <- function(x, y) { # nom de la funció f, variable x i y
  # cos de la funció
  x + y # es pot retornar la darrera operació, o bé escrivint explícitament return(x+y)
}
```

Podem veure si un objecte és un funció mitjançant el test `is.function()`. Com hem comentat anteriorment, una funció és un objecte per ell mateix i pot utilitzar-se com qualsevol altre
variable. Per exemple, pot formar part del conjunt de variables d'un funció:

```{r}
# Es defineix una funció g que aplica a una funció f
g <- function(f, x) f(x, x^2) 

g(function(x,y){
    x+y
  }, 10)
```

# Variables aleatòries {#variables}

Una variable aleatoria $X$ és una funció que assigna esdeveniments aleatoris d'un espai $\Omega$ a un subconjunt de l'espai real $\mathbb{R}$. Les variable aleatòries es separen en dos grups: [discretes](#var_discretes) i [contínues](#var_continues).

## Variable aleatòries discretes {#var_discretes}

Imaginem que estem interessats en modelar el color dels ulls de les persones (suposem els colors marró/brown, verd/green i blau/blue) amb una variable aleatòria. Suposem que el nostre espai d'esdeveneniments és $\Omega = \{ \text{brown}, \text{green}, \text{blue} \}$. Definim la variable aleatoria $X_1$ que assigna valors com $X_1( \text{brown} ) = 1$,  $X_1( \text{green} ) = 2$ i  $X_1( \text{blue} ) = 3$.

```{r}
X1 <- function(color){
  valor <- NA
  if( color == "brown") valor = 1
  if( color == "green") valor = 2
  if( color == "blue") valor = 3
  valor
}
```

Suposem que la probabilitat de tenir els ulls marrons, verds i blaus són 0.5, 0.3, 0.2. A continuació utilitzarem la funció `sample()` d'R per crear 100 observacions d'ulls de persones seguint les probabilitats esmentades.

```{r}
mostra <- sample( x = c("brown", "green", "blue"), size = 100, replace = TRUE, prob = c(0.5, 0.3, 0.2))
```

Per assegurar que tots obtinguem els mateixos valors després de la generació aleatòria, podem utilitzar la funció `set.seed()` que ens permet fixar una llavor al procés aleatori.

```{r}
set.seed(1) # ens assegurem que tots tenim la mateixa llavor
mostra <- sample( x = c("brown", "green", "blue"), size = 100, replace = TRUE, prob = c(0.5, 0.3, 0.2))
```

Podem comptar quant individus han resultat amb cada color amb la funció `table()`

```{r}
table(mostra)
```

podem dividir per la llargada del vector (`length()`) per obtenir-ne la freqüència relativa

```{r}
table(mostra) / length(mostra)
```

### Funció de probabilitat i de distribució

La funció de probabilitat de la variable aleatòria $X_1$ és

\[
p(x) = P( \{ X_1(\omega) = x \} ) = 
\left\{ 
\begin{align}
0.5 & \text{si x = 1}\\
0.3 & \text{si x = 2}\\
0.2 & \text{si x = 3}\\
0 & \text{altrament}
\end{align}
\right.
\]

```{r}
p <- function(x){
  prob <- rep(0, length(x))
  prob[x == 1] <- 0.5
  prob[x == 2] <- 0.3
  prob[x == 3] <- 0.2
  prob
}
```

Podem graficar la funció de probabilitat utilitzant la funció `plot()` d'R.

```{r, fig.width=5, fig.height=4}
x <- 0:5
df.p <- data.frame('x' = x, 'p.x' = p(x))
plot(df.p, type='h', ylim = c(0, 1), main = "Funció de probabilitat de X1")
```

Si volem graficar la funció de distribució podem utilitzar la funció `cumsum()` que ens permet acumular el valors d'un vector

```{r, fig.width=5, fig.height=4}
x <- 0:5
df.F <- data.frame('x' = x, 'F.x' = cumsum(p(x)))
plot(df.F, type='s', ylim = c(0, 1), main = "Funció de distribució de X1")
```

## Variable aleatòries contínues  {#var_continues}

Volem modelar l'alçada d'una persona utilitzant una variable aleatòria. Suposem que per modelar l'alçada escollim una variable aleatòria $X_2$ normal amb mitjana $\mu = 1.65$ i $\sigma = 0.075$, escrit breument, $X_2 \sim N(\mu=1.65, \sigma=0.075)$.

R disposa de la funció `rnorm()` que ens permet generar variables normals amb una mitjana i desviació específica.

```{r}
set.seed(1)
alcades <- rnorm(n = 100, mean = 1.65, sd = 0.075)
```

Amb la funció `summary()` podem obtenir una descriptive senzilla d'una vector numèric.

```{r}
summary(alcades)
```

La funció `hist()` permet dibuixar l'histograma d'un vector numèric.

```{r, fig.width=5, fig.height=4}
hist(alcades, main='Histograma d\'alçades', xlab='Alçada (metres)', ylab='Freqüència')
```

### Funció de densitat i de distribució

La funció de densitat d'una variable normal s'escriu com

\[
f(x) = \frac{1}{\sigma \sqrt(2 \pi)} exp\left\{ -\frac{(x-\mu)^2}{2 \sigma^2}  \right\}.
\]

La funció `dnorm()` ens permet calcular el valor de la funció de densitat d'una variable normal en un punt concret. Amb aquesta funció podem dibuixar la funció de densitat de la variable aleatòria $X_2$.

```{r, fig.width=5, fig.height=4}
x = seq(from = 1.3, to = 2, by = 0.01)
df.f = data.frame('x' = x, 'f.x' = dnorm(x, mean = 1.65, sd = 0.075))
plot(df.f, type='l', main = 'Funció de densitat de X2')
```


La funció de distribució la podem calcular amb la funció `qnorm()`.

```{r, fig.width=5, fig.height=4}
x = seq(from = 1.3, to = 2, by = 0.01)
df.F = data.frame('x' = x, 'f.x' = pnorm(x, mean = 1.65, sd = 0.075))
plot(df.F, type='l', main = 'Funció de distribució de X2')
```

# Activitats {#activitats}

## Càlcul de probabilitats

Imaginem que els paràmetre d'una població és desconegut per nosaltres.

```{r}
set.seed(1)
mu = runif(1, min = 10, max = 20)
desv = runif(1, min = 0, max = 2)
```

